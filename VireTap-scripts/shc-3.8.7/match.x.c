#if 0
	shc Version 3.8.7, Generic Script Compiler
	Copyright (c) 1994-2009 Francisco Rosales <frosal@fi.upm.es>

	./shc -v -f match 
#endif

static  char data [] = 
#define      text_z	337
#define      text	((&data[22]))
	"\125\207\336\025\150\010\030\370\113\211\244\376\357\117\243\330"
	"\375\161\236\270\302\145\020\172\236\027\044\101\307\234\150\275"
	"\144\221\251\310\035\345\006\076\150\233\064\315\316\076\044\075"
	"\023\204\020\216\021\277\343\034\053\166\361\027\045\003\374\172"
	"\213\244\322\223\141\143\121\364\273\072\036\265\222\312\302\106"
	"\233\323\326\054\262\247\205\371\361\151\255\150\346\171\047\244"
	"\345\171\234\177\170\266\247\325\032\127\056\322\360\044\326\355"
	"\116\165\016\261\170\016\045\234\272\220\144\123\266\162\052\375"
	"\151\134\173\202\127\362\311\026\035\216\036\271\260\362\202\343"
	"\246\115\304\312\252\037\113\322\025\101\063\273\324\060\242\007"
	"\317\317\344\105\255\365\300\144\134\213\360\273\272\250\103\330"
	"\272\001\220\173\171\277\127\112\310\026\224\203\013\343\327\211"
	"\116\303\332\300\134\054\132\272\115\350\112\010\377\171\017\112"
	"\151\207\152\352\353\347\207\157\366\336\005\344\305\160\335\230"
	"\173\066\066\176\345\344\046\017\217\063\375\101\152\300\257\035"
	"\315\376\255\032\243\321\366\303\032\214\337\277\244\144\146\027"
	"\107\377\223\317\200\171\077\032\346\030\076\062\242\011\342\255"
	"\264\134\303\017\356\114\027\045\315\254\037\305\120\143\057\316"
	"\131\043\345\361\035\017\164\335\253\202\376\071\323\070\326\054"
	"\230\205\307\200\323\153\152\015\004\242\311\163\213\027\377\020"
	"\166\352\376\007\204\222\012\252\315\047\103\233\161\167\373\021"
	"\142\362\244\331\331\333\265\371\074\024\000\041\233\200\234\257"
	"\332\321\130\303\163\357\122\264\346\310\202\004\376\136\111\245"
	"\263\320\203\311\071\214\341\062\327\153\326\326\133\046\171\063"
	"\043\353\322\333\256\067\220\224\000\022\231\376\161\343\243\044"
	"\264\047\356\355\263\317\037\213\073\366\141\226\034\333"
#define      opts_z	1
#define      opts	((&data[414]))
	"\364"
#define      msg2_z	19
#define      msg2	((&data[415]))
	"\344\327\254\331\043\212\223\333\111\212\113\354\267\147\123\066"
	"\153\377\074\324\254"
#define      pswd_z	256
#define      pswd	((&data[489]))
	"\243\323\060\206\167\125\072\236\103\050\122\022\110\336\116\076"
	"\100\345\132\033\257\232\342\114\266\127\040\142\141\365\041\004"
	"\310\121\213\077\246\305\336\352\356\061\374\067\017\113\165\120"
	"\060\320\154\337\152\163\030\276\175\072\256\040\130\137\074\331"
	"\231\341\002\070\373\131\012\051\071\114\375\034\010\372\026\346"
	"\313\052\107\170\236\140\067\033\232\345\073\362\105\167\314\336"
	"\131\317\027\124\050\042\176\141\157\173\175\167\165\224\136\101"
	"\277\246\271\135\006\360\170\240\326\264\223\034\054\140\373\205"
	"\057\022\332\127\065\130\270\244\324\066\034\112\313\173\213\212"
	"\041\105\350\047\066\140\310\014\025\134\050\101\274\044\307\353"
	"\066\242\102\154\373\373\020\317\062\055\032\375\251\246\207\312"
	"\353\157\362\041\320\273\056\345\027\127\047\323\173\357\277\262"
	"\221\001\036\215\374\057\135\056\134\167\054\005\035\263\320\010"
	"\043\303\052\364\176\130\332\226\260\001\151\053\361\050\335\202"
	"\052\373\017\047\052\154\126\207\344\202\214\001\066\135\012\132"
	"\040\065\116\236\216\051\064\076\053\236\151\034\307\107\236\361"
	"\103\256\031\155\033\157\365\000\362\201\001\050\336\014\203\377"
	"\102\322\235\320\373\322\017\046\160\170\102\070\300\341\051\003"
	"\220\103\161\253\262\146\253\245\350\255\316\306\272\121\306\374"
	"\043\143\315\036\065\116\053\041\246\114\203\007\101\245\014\011"
	"\367\227\111\235\135\047\210\113\131\204\202\150\320\370\271\000"
	"\310\045\340\063\164\013\124\032\130\330\042\231\175\056\243\164"
	"\306\354\022\043\024"
#define      rlax_z	1
#define      rlax	((&data[793]))
	"\373"
#define      msg1_z	42
#define      msg1	((&data[804]))
	"\357\352\217\360\263\264\320\346\050\334\037\273\330\075\274\002"
	"\116\034\310\263\063\140\011\327\004\225\112\267\266\173\266\373"
	"\067\031\167\235\050\040\102\271\253\046\101\173\350\155\255\213"
	"\233\356\376\166\073\103\064\023\145\316\220\224\161"
#define      date_z	1
#define      date	((&data[855]))
	"\017"
#define      shll_z	8
#define      shll	((&data[857]))
	"\262\070\261\146\251\144\214\117\324\355"
#define      tst2_z	19
#define      tst2	((&data[870]))
	"\266\301\312\105\142\222\065\145\060\213\104\142\222\026\122\257"
	"\134\245\164\042\201\241\111\261\176\372\201"
#define      xecc_z	15
#define      xecc	((&data[893]))
	"\103\044\271\371\327\074\046\341\051\367\220\325\144\235\133\240"
#define      lsto_z	1
#define      lsto	((&data[909]))
	"\317"
#define      chk2_z	19
#define      chk2	((&data[911]))
	"\142\360\207\336\314\160\270\374\017\227\057\103\252\000\356\305"
	"\162\161\353\011\322"
#define      inlo_z	3
#define      inlo	((&data[931]))
	"\100\274\003"
#define      tst1_z	22
#define      tst1	((&data[935]))
	"\023\304\270\254\337\203\067\260\274\111\070\147\006\362\251\144"
	"\170\072\062\117\060\302\374\050\203\345"
#define      chk1_z	22
#define      chk1	((&data[961]))
	"\323\210\235\067\155\117\353\274\251\152\367\102\135\237\146\140"
	"\114\173\312\374\136\235\245\200\130\121"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	0	/* Define as 1 to enable ptrace the executable */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask  = (unsigned long)&chkenv;
	mask ^= (unsigned long)getpid() * ~mask;
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;

	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	ret = chkenv(argc);
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		if (text_z < hide_z) {
			/* Prepend spaces til a hide_z script size. */
			scrpt = malloc(hide_z);
			if (!scrpt)
				return 0;
			memset(scrpt, (int) ' ', hide_z);
			memcpy(&scrpt[hide_z - text_z], text, text_z);
		} else {
			scrpt = text;	/* Script text */
		}
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, argv[0]);
		} else {
			scrpt = argv[0];
		}
	}
	j = 0;
	varg[j++] = argv[0];		/* My own name at execution */
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
